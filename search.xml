<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript基础学习]]></title>
    <url>%2Fnormal%2F2019%2F5%2Fjavascript-ji-chu-xue-xi%2F</url>
    <content type="text"><![CDATA[JavaScript基础学习 JavaScript，简称JS，是一种高级的、解释执行的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式语言，它支持面向对象编程，以及函数式编程。它被世界上的绝大多数网站使用，也被世界主流浏览器支持。 作用域在JavaScript中，对象和函数同样也是变量。 在JavaScript中，作用域可访问变量，对象，函数的集合。 对于变量而言，在JavaScript中有两个范围：全局和局部。在函数定义之外的声明的变量属全局变量，它在整个应用程序（也就是整个页面的js）都可以访问；反之，函数定义之内的声明的变量属局部变量，每当函数执行时，会创建变量，当函数执行完成后，都会销毁变量，并且该函数之外的内容无法访问该变量。 在JavaScript中同样也支持块作用域。 块作用域主要有for,if,with,tyr/catch,let,const。 123for(var i=o;i&lt;10;i++)&#123; console.log(i);&#125; 因为在for循环内部定义了i变量，顾i变量只能在for循环体内使用。 123456var foo = true;if (foo) &#123; var bar = foo * 2; bar = something( bar ); console.log( bar );&#125; bar变量仅声明在if的上下文中，因此在使用bar变量的时候，只能在if的方法体内使用。 with语句的作用是将代码的作用域设置到一个特定的作用域中，with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 比如： 123456789101112131415var obj = &#123; a: 1, b: 2, c: 3&#125;;// 单调乏味的重复 "obj"obj.a = 2;obj.b = 3;obj.c = 4;// 简单的快捷方式with (obj) &#123; a = 3; b = 4; c = 5;&#125; try/catch相对比较容易理解，就是try与catch创建的{}代码块属于一个块作用域。 let是ES6提出的一个新的声明变量的关键字，let关键字可以将变量绑定在其所在的任意作用域中，通常是{}中，但这是一种隐式行为。 const，与let相似的，const也是ES6引入的一个新的声明变量的关键字，但其值是固定的，即常量。 基础类型在JavaScript中共有6中基本数据类型： Undefined：表示一个对象未定义 Null：对象已经定义，但这个对象是空的，即空指针对象 Boolean：布尔类型，该类型只有两个值true、false Number：数字类型，包括整数、浮点数，当然也支持十进制、八进制、十六进制表示。另外Number还有一个特殊的值，NaN，该值用于表示一个本来要返回数值的对象，但未返回数值的情况 String：字符串类型 Symbol：ES6新引入的数据类型，它表示一个独一无二的值，其作用是放置属性名冲突 基础类型比较： 在JavaScript中，比较两个基础类型，JS会自动读数据进行隐式转换，比如: 1234var a = 1;var b = true;console.log(a == b); // trueconsole.log(a === b); // false 在JavaScript中， ==，双等号只进行值比较，如果两者数据不同意，则会自动转成同意的数据格式进行比较，当然如果转换格式失败，则会抛出异常。===，三等又称强等号，三等不仅会验证值是否一致，同时也是验证数据格式是否一致。 基础类型的变量存在在栈内存(Stack)中。 引用类型JavaScript中的引用类型，即Object类型，对象类型，对象可以是一个类型的实例化对象，也可以是一组数据源，也可以是一个功能函数。在JavaScript中，Object又有许多子类型，如：Array，Date，RegExp，Function等。 RegExp类型，即正则表达式，在JavaScript中，它是用于描述字符模式的对象，正则表达式用于对字符模式匹配、检索替换，是操作字符串执行模式匹配的强大工具。其使用方式如下： 1234//验证字符串是否全数字var re = new RegExp("^[0-9]*$");var str = '123213123're.test(str)//true 对于RegExp支持的字符串方法有：search、match、replace、split。 Function，函数类型，每个函数都是Function类型的实例。 对于函数，其返回值比较特殊，如果其方法体内没有返回值，则返回一个undefined。 1234567891011121314function test1()&#123; &#125;function test2()&#123; return 1;&#125;function test3()&#123; return ;&#125;var t1 = test1();var t2 = test2();var t3 = test3();console.log(t1);//undefinedconsole.log(t2);//1console.log(t3);//undefined 对于引用类型的值是按照引用访问的。所以在比较引用类型的时候，双等号与三等号作用相同，比较的是两个对象的引用地址，引用地址相同，才会返回true。例如： 1234var obj1 = &#123;&#125;; // 新建一个空对象 obj1var obj2 = &#123;&#125;; // 新建一个空对象 obj2console.log(obj1 == obj2); // falseconsole.log(obj1 === obj2); // false 引用类型的值存在堆内存(Heap)中。 虽然引用类型保存在堆内存中，但是JavaScript不能直接操作堆内存，所以在JavaScript中，栈内存中保存了变量标识符和指向堆内存中该对象的指针，堆内存中保存了对象的内容。 检测类型在JavaScript中，有两个较特殊的关键字，分别为typeof、instanceof。 typeof主要用来检测一个变量是否为基本的数据类型。 1234567891011121314151617181920var a;typeof a; // undefineda = null;typeof a; // objecta = true;typeof a; // booleana = 666;typeof a; // number a = "hello";typeof a; // stringa = Symbol();typeof a; // symbola = function()&#123;&#125;typeof a; // functiona = [];typeof a; // objecta = &#123;&#125;;typeof a; // objecta = /aaa/g;typeof a; // object instanceof主要用来检测构造函数的prototype属性所指向的对象是否存在于另一个检测对象的原型链（关于原型链见下文）上。 1234(&#123;&#125;) instanceof Object // true([]) instanceof Array // true(/aa/g) instanceof RegExp // true(function()&#123;&#125;) instanceof Function // true]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.0整合Activiti6.0问题梳理]]></title>
    <url>%2Fnormal%2F2019%2F5%2Fspringboot2.0-zheng-he-activiti6.0-wen-ti-shu-li%2F</url>
    <content type="text"><![CDATA[SpringBoot2.0整合Activiti6.0问题梳理SpringBoot整合Activiti很简单，我们可以通过springboot的starter来快速整合，只需要在pom文件中引入一下内容即可： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt;&lt;/dependency&gt; 详细源码请见:https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act 在Activiti6.0发布的时候，SpringBoot2.0还未发布，所以直接启动，会出现如下错误: 12345678910111213141516171819202122232425262728293031323334353637383940org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;requestMappingHandlerMapping&apos; defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1706) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:579) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:501) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:317) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:315) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:760) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:869) ~[spring-context-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:759) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:395) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE] at pers.jarome.scs.act.ActApplication.main(ActApplication.java:17) [classes/:na]Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_181] at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_181] at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_181] at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_181] at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_181] at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_181] at java.lang.Class.createAnnotationData(Class.java:3521) ~[na:1.8.0_181] at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_181] at java.lang.Class.createAnnotationData(Class.java:3526) ~[na:1.8.0_181] at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_181] at java.lang.Class.getAnnotation(Class.java:3415) ~[na:1.8.0_181] at java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:258) ~[na:1.8.0_181] at java.lang.Class.isAnnotationPresent(Class.java:3425) ~[na:1.8.0_181] at org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation(AnnotatedElementUtils.java:573) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.isHandler(RequestMappingHandlerMapping.java:177) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:217) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:188) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:129) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1765) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1702) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE] ... 16 common frames omitted 查阅网上资料得知是因为，Activiti6.0发布时，SpringBoot2.0 并没有发布，所以Activiti6.0仅支持1.2.6以上，2.0.0以下版本的SpringBoot。 通过调试（调试方式可以参照这一篇博客：深入Spring Boot：怎样排查 java.lang.ArrayStoreException）查看源码很容易发现SecurityAutoConfiguration源码因为SpringBoot内部结构的变化，从而引起该类出现编译错误。 针对这一类情况有三种解决办法，分别如下： 将springboot2.0换成1.X版本 在springboot启动类上排除SecurityAutoConfiguration类 修改SecurityAutoConfiguration源码，使其支持SpringBoot2.0 对于上诉的三种方法，第一种最为简单，直接切换版本即可，但这样就不能使用SpringBoot2.0的特性，所以并不推荐；对于第三种方法，我认为难度较大，且具备极大的风险，并且Activiti的更高版本肯定也会修复，所以也不推荐该方法。 所以，最优的方法当属第二种，其具体操作如下： 1234567891011@SpringBootApplication(exclude = org.activiti.spring.boot.SecurityAutoConfiguration.class)public class ActApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ActApplication.class); &#125;&#125;public class ActApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ActApplication.class); &#125;&#125; 但是，如果你的启动类中加入了@EnableAutoConfiguration注解，上面的方法就失效了，此时应该使用下面的方式： 1234567@SpringBootApplication@EnableAutoConfiguration(exclude = org.activiti.spring.boot.SecurityAutoConfiguration.class)public class ActApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ActApplication.class); &#125;&#125; 详细源码请见:https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud快速构建]]></title>
    <url>%2Fjava%2F2019%2F5%2Fspringcloud-kuai-su-gou-jian%2F</url>
    <content type="text"><![CDATA[SpringCloud快速构建 SpringCloud是2014年底Spring团队基于SpringBoot开发的，推出的Java领域微服务架构完整解决方案。主要包括服务注册于发现、配置中心、全链路监控、API网关、熔断器等选型中立的开源组件。 基础组件列表如下： 名称 功能 简介 Eureka 注册中心 保证一致性与高可用 Consul 注册中心 保证强一致性 Zuul 网关 第一代网关 Gateway 网关 第二代网关 Ribbon 负载均衡 进程内负载均衡 Hystrix 熔断器 延迟、容错 Fegin 声明式HTTP客户端 Sleuth 链路追踪 Config 配置中心 Bus 总线 EurekaEureka是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。 添加依赖： 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在启动类中添加@EnableEurekaServer注解： 1234567@SpringBootApplication@EnableEurekaServerpublic class SpringCloudEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudEurekaApplication.class, args); &#125;&#125; 编写对应的配置文件： 123456789101112spring: application: name: spring-cloud-eurekaserver: port: 8000eureka: client: register-with-eureka: false fetch-registry: false serviceUrl: defaultZone: http://localhost:$&#123;server.port&#125;/eureka/ FeignSpring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。 引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类中添加@EnableFeignClients注解 123456789@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子： 1234567@FeignClient("eureka-client")public interface DcClient &#123; @GetMapping("/dc") String consumer();&#125; @FeignClient注解： name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现 url: url一般用于调试，可以手动指定@FeignClient调用的地址 decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contract fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口 fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码 path: 定义当前FeignClient的统一前缀 HystixHystix是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。 添加依赖： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 启动类上增加Hystrix的注解： 1234567891011121314@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic class HystrixRibbonApp &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixRibbonApp.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 修改代码逻辑，在需要熔断的方法上增加@HystrixCommand注解，当调用有问题的时候就会使用fallbackMethod参数指定的方法进行服务降级： 1234567891011121314151617181920212223242526272829303132333435@RestControllerpublic class HelloController &#123; @Autowired HystrixRibbonService helloService; @RequestMapping("/hi") public String hello()&#123; return helloService.helloService("姓名"); &#125;&#125;@Servicepublic class HystrixRibbonService &#123; private static final String SERVICE_NAME = "EUREKACLIENT"; @Autowired RestTemplate restTemplate; @Autowired private LoadBalancerClient loadBalancerClient; @HystrixCommand(fallbackMethod = "helloServiceFallBack") public String helloService(String name) &#123; ServiceInstance serviceInstance = this.loadBalancerClient.choose(SERVICE_NAME); System.out.println("服务主机：" + serviceInstance.getHost()); System.out.println("服务端口：" + serviceInstance.getPort()); // 通过服务名来访问 return restTemplate.getForObject("http://" + SERVICE_NAME + "/hello?name="+name,String.class); &#125; @SuppressWarnings("unused") private String helloServiceFallBack(String name) &#123; return "这个是失败的信息！"; &#125;&#125; 在Feign中同样可以使用Hystix，在Feign中指定fallback，示例如下： 123456789101112@FeignClient(value="EUREKACLIENT", fallback = HystrixFeignServiceFallback.class)public interface HystrixFeignService &#123; @RequestMapping(value = "/hello",method = RequestMethod.GET) String sayHiUseFeign(@RequestParam(value = "name") String name);&#125;@Componentpublic class HystrixFeignServiceFallback implements HystrixFeignService&#123; @Override public String sayHiUseFeign(String name) &#123; return "feign调用错误！"; &#125;&#125; Zuul在说Zuul之前，应先理解API Gateway(API网关)的概念，API网关即给用户规定一个统一的入口，接收到用户请求后，网关在内部会分发到各个对应的服务服务上。API网关的好处： 简化客户端调用复杂度 数据裁剪以及聚合 多渠道支持 遗留系统的微服务化改造 Spring Cloud Zuul路由是微服务架构的不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。 引用依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件: 123456789101112spring: application: name: gateway-service-zuulserver: port: 8888#这里的配置表示，访问/goo/** 直接重定向到http://www.google.comzuul: routes: baidu: path: /goo/** url: http://www.google.com 启动类： 12345678@SpringBootApplication@EnableZuulProxypublic class GatewayServiceZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayServiceZuulApplication.class, args); &#125;&#125; 网关服务化添加eureka依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件： 12345678910111213141516spring: application: name: gateway-service-zuulserver: port: 8888zuul: routes: server-a: path: /goo/** serviceId: server-aeureka: client: serviceUrl: defaultZone: http://localhost:8000/eureka/ 其中server-a为eureka中的服务。 SleuthSleuth是Spring Cloud的组成部分之一，为SpringCloud应用实现了一种分布式追踪解决方案，其兼容了Zipkin, HTrace和log-based追踪 几个基本术语： Span：基本工作单元，发送一个远程调度任务 就会产生一个Span，Span是一个64位ID唯一标识的，Trace是用另一个64位ID唯一标识的，Span还有其他数据信息，比如摘要、时间戳事件、Span的ID、以及进度ID。 Trace：一系列Span组成的一个树状结构。请求一个微服务系统的API接口，这个API接口，需要调用多个微服务，调用每个微服务都会产生一个新的Span，所有由这个请求产生的Span组成了这个Trace。 Annotation：用来及时记录一个事件的，一些核心注解用来定义一个请求的开始和结束 。这些注解包括以下： cs - Client Sent -客户端发送一个请求，这个注解描述了这个Span的开始 sr-Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络传输的时间。 ss - Server Sent （服务端发送响应）–该注解表明请求处理的完成(当请求返回客户端)，如果ss的时间戳减去sr时间戳，就可以得到服务器请求的时间。 cr - Client Received （客户端接收响应）-此时Span的结束，如果cr的时间戳减去cs时间戳便可以得到整个请求所消耗的时间。 Spring Cloud Sleuth和Zipkin分布式链路跟踪Zipkin服务端构建Zipkin 是一个开放源代码分布式的跟踪系统，由Twitter公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。 每个服务向zipkin报告计时数据，zipkin会根据调用关系通过Zipkin UI生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。 Zipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。接下来的测试为方便直接采用In-Memory方式进行存储，生产推荐Elasticsearch。 首先在项目中添加依赖 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写对应的启动类，使用了@EnableZipkinServer注解，启用Zipkin服务。 12345678@SpringBootApplication@EnableEurekaClient@EnableZipkinServerpublic class ZipkinApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZipkinApplication.class, args); &#125;&#125; 修改配置文件 123456789eureka: client: serviceUrl: defaultZone: http://127.0.0.1:8761/eureka/server: port: 9000spring: application: name: zipkin-server 配置完成后依次启动示例项目：spring-cloud-eureka、zipkin-server项目。刚问地址:http://localhost:9000/zipkin/可以看到Zipkin后台页面 客户端添加zipkin支持在项目中添加如下依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件中添加如下代码： 123456spring: zipkin: base-url: http://localhost:9000 sleuth: sampler: percentage: 1.0 spring.zipkin.base-url指定了Zipkin服务器的地址，spring.sleuth.sampler.percentage将采样比例设置为1.0，也就是全部都需要。 Spring应用在监测到Java依赖包中有sleuth和zipkin后，会自动在RestTemplate的调用过程中向HTTP请求注入追踪信息，并向Zipkin Server发送这些信息。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置]]></title>
    <url>%2Fserver%2F2018%2F12%2Fnginx-pei-zhi%2F</url>
    <content type="text"><![CDATA[nginx配置nginx常用编译参数对于nginx，如果使用源码安装，在进行./configure编译的时候，需要为其指定一些参数。 –prefix=PATH ： 指定nginx的安装目录。默认 /usr/local/nginx –conf-path=PATH ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为prefix/conf/nginx.conf –user=name： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。–group=name类似 –with-pcre ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用–with-pcre自动找到库文件。使用–with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（版本4.4 – 8.30）并解压，剩下的就交给Nginx的./configure和make来完成。perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。 –with-zlib=PATH ： 指定 zlib（版本1.1.3 – 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块ngx_http_gzip_module时需要使用zlib 。 –with-http_ssl_module ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装 –with-http_stub_status_module ： 用来监控 Nginx 的当前状态 –with-http_realip_module ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址 –add-module=PATH ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译） config基本配置概览 Nginx的配置文件默认在Nginx程序安装目录的conf目录下，其中核心文件为nginx.conf，当然你也可以自己写配置文件，然后在nginx.conf中引用。 nginx.conf配置具体信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 65535;&#125;#设定http服务器http&#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型 #charset utf-8; #默认编码 server_names_hash_bucket_size 128; #服务器名字的hash表大小 client_header_buffer_size 32k; #上传文件大小限制 large_client_header_buffers 4 64k; #设定请求缓 client_max_body_size 8m; #设定请求缓 sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。 tcp_nopush on; #防止网络阻塞 tcp_nodelay on; #防止网络阻塞 keepalive_timeout 120; #长连接超时时间，单位是秒 #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用 upstream blog.ha97.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; &#125; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.ha97.com ha97.com; index index.html index.htm index.php; root /data/www/ha97; location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #日志格式设定 log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;; #定义本虚拟主机的访问日志 access_log /var/log/nginx/ha97access.log access; #对 &quot;/&quot; 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*. (htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125; nginx常用配置说明nginx日志文件配置关于日志文件的配置主要有两个属性log_format、access_log、error_log。 log_formatlog_format为日志格式，其语法为： 1log_format name format &#123;format ... &#125; 其中，name表示日志名字，format表示定义的格式样式。 log_format有一个默认的、无需配置的combined日志格式： 123log_format combined &apos;$remote_addr-$remote_user [$time_local]&apos;&quot;$request&quot;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; 在日志格式中的变量主要有： 参数 说明 示例 $remote_addr 反向代理服务器的IP地址 127.0.0.1 $remote_user 远程客户端用户名称 – $time_local 访问时间与时区 18/Jul/2012:17:00:01 +0800 $request 请求URL与HTTP协议 GET /article-10000.html HTTP/1.1 $status 请求状态，例如成功时状态为200，页面找不到时状态为404 200 $body_bytes_sent 发送客户端的文件主体内容大小 1000 $upstream_status upstream状态 200 $http_referer 访问来源 https://www.baidu.com/ $http_user_agent 客户浏览器的相关信息 Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C; $ssl_protocol SSL协议版本 TLSv1 $ssl_cipher 交换数据中的算法 RC4-SHA $upstream_addr 后台upstream的地址，即真正提供服务的主机地址 10.10.10.100:80 $request_time 整个请求的总时间 0.205 $upstream_response_time 请求过程中，upstream响应时间 0.002 $http_host 请求地址，即浏览器中你输入的地址（IP或域名） www.baidu.com 192.168.1.1 access_logaccess_log主要用于记录nginx访问日志。其语法如下： 1access_log path [foramt &#123;buffer-size | off&#125; 关闭日志方法：access_log off。 使用默认combined格式记录日志：access_log path。 使用自定义格式记录日志，首先定义一个log_format，如log_format customformat ‘具体配置’。 access_log path customformat buffer=32k。 结尾的buffer代表缓冲区大小。 error_log与access_log不同的是，error_log主要记录nginx运行过程中的错误日志。其语法如下 1error_log &lt;FILE&gt; &lt;LEVEL&gt; 其中参数含义如下： FILE：代表日志文件存放目录。 LEVEL：错误日志级别。 常见的错误日志级别有：debug | info | notice | warn | error | crit | alert | emerg ，级别越高记录的错误信息越少。对于我们而言，一般用到的为warn，error,crit。 nginx压缩输出nginx压缩输出使用的技术为gzip(GNU-ZIP)压缩技术。经过gzip压缩后的页面大小可以变为原来的30%以下，压缩页面后可以降低用户在浏览页面时下载资源的时间，但gzip有个明显的去诶按，就是需要服务端与客户端同步支持gzip，即服务器压缩，浏览器解压。目前IE、Chrome等主流浏览器均具备解压gzip的功能。 nginx中的gzip指令如下： 开启或关闭gzip 1gzip on|off 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流 1gzip_buffers number size 设置gzip压缩比例 1gzip_comp_level 1..9 设置允许压缩的页面最小字节数，当页面超过该数值时才进行压缩，其默认为0，即所有页面都进行压缩 1gzip_min_length length nginx作为静态服务器nginx其根本上是一个HTTP服务器，可以将服务器撒花姑娘的静态资源文件（如HTML、JS、Image）通过HTTP协议展现给客户端。 123456server &#123; listen 80; # 端口号 location / &#123; root /usr/share/nginx/html; # 静态文件路径 &#125;&#125; nginx负载均衡与反向代理负载均衡 负载均衡就是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。 常见的复杂均衡主要有： 用户手动选择：通过用户手动选择线路。 DNS轮询：为域名添加多个解析记录。 四/七层负载均衡设备：硬件实现负载均衡，如F5。软件实现为LVS。 Nginx负载均衡 反向代理 反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求发给内部网路上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 具体实现在nginx中，通过Upstream可以设置一组在proxy_pass和fastcgi_pass指令中使用的代理服务器，默认的负载均衡方式为轮询，Upstream模块中的Server指令用于指定后端服务器的名称和参数，服务器的名称可以是一个域名、一个IP地址、端口号或UNIX Socket。 而在server{}虚拟主机内，可以通过proxy_pass和fastcgi_pass指令设置进行反向代理的服务器集群。 proxy_set_header指令用于在向反向代理的后端Web服务器发起请求时添加指定的Header头信息。 当后端Web服务器上有多个基于域名的虚拟主机时，要通过添加Header头信息Host，用于指定请求的域名，这样后端Web服务器才能识别该方向代理访问请求由哪一个虚拟主机来处理。 在使用方向代理后，连接通过代理服务器链接到目标服务器后，如果在目标服务器中存在获取用户真实IP的代码（比如，Java、PHP等后台语言）就会失效，这时服务器获取的是代理服务器的IP。如果要获取真实IP，需要在nginx反向代理配置里添加Header头信息：X-Forwarded-For,让目标服务器能够获取用户的真实IP。 具体配置如下： 1234567891011121314151617upstream baidu.com &#123; # weight 设置权重 server 127.0.0.1:8881 weight=3; server 127.0.0.1:8882; server 127.0.0.1:8888;&#125;server&#123; listen 80; server_name baidu.com; location / &#123; proxy_pass http://baidu.com; proxy_set_header Host $host; #获取真实IP设置 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>网关</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring核心原理]]></title>
    <url>%2Fjava%2F2018%2Fsrping-he-xin-yuan-li%2F</url>
    <content type="text"><![CDATA[Spring核心原理 在Spring中拥有许多的组件，但核心部分主要为：Beans、Core、Context、Expression，其中最为主要的为Core、与Beans，它们提供了最为核心的IOC和依赖注入功能。下文主要从这两个着手进行说明。 设计思想Spring5架构图： Spring框架设计理念 在Spring框架中，其最核心组件应属Beans，Spring-Beans模块是所有应用都必须使用的，它包含了访问配置文件、创建和管理Bean以及进行控制反转(IOC，Inversion of Control)、依赖注入(DI,Dependency Injection)操作相关的所有类。 在IBM developerWorks一文中(https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/index.html)这样说道：Spring就是面向Bean编程（BOP,Bean Oriented Programming），Bean 在 Spring 中才是真正的主角。 Bean生命周期 在Spring中Bean贯穿整个Spring应用，其生命周期应是从Spring容器创建后开始，直至Spring容器主动或被动销毁Bean。 在Spring中，Bean默认为单例模式，即singleton属性默认为false，从BeanFactory中取得的Bean实例为在其初始化就产生一个新的对象，而不是每次获取的时候都产出一个新的对象。当然我们也可以在初始化Bean的时候设置其singleton属性为true，使这个Bean变成多例模式，在getBean的时候，Spring都会产出一个新的对象，类似于Java的中的new Object操作。但设置其为多例，应避免多线程同时存取共享资源所引发的数据不同步问题。 然后在Spring中，一个Bean从创建到销毁，大致需要经历一下几个步骤（其具体的实现方式，将在下放继续阐述）： 实例化Bean，根据Spring配置，执行包扫描操作，并对其进行实例化操作。 根据Spring上线文对实例化的Bean进行配置，其中包括依赖注入。 判断是否实现了BeanNameAware接口，如果有会执行setBeanName方法去设置这个Bean的id，即自己设置Bean在BeanFactory中的名字。 判断是否实现了BeanFactoryAware接口，如果有则执行setBeanFactory方法，使得Bean可以获取自己的工厂，从而可以使用工厂的getBean方法。 判断是否实现了ApplicationContextAware接口，如果有则执行setApplicationContext方法，使得在Bean中可以获取Spring上下文，从而可以获取通过上下文去getBean，该步骤与上一步作用大致相同，但通过该中方式能实现的功能却更加丰富。 判断是否实现了BeanPostProcessor接口，如果有则调用postProcessBeforeInitialization方法，这一步属于实例化Bean的前置操作，在经过该步骤后，即Bean实例化后同样也会执行一个操作，详情见第八条。 判断Bean是否配置了init-method，如果有，在Bean初始化之后会默认执行一次init-method指定的方法。 判断Bean是否实现了BeanPostProcessor接口，如果有则调用postProcessAfterInitialization方法，该方法属于Bean实例化后的操作。在经过这个步骤后，Bean的初始化操作就完成了。 当Bean实例化完成后，当Bean不再被需要的时候会执行销毁操作。一般是在ApplicationContext执行close方法时会进行销毁操作。 在销毁过程中，判断是否实现了DisposableBean接口，如果有则执行destroy方法。 判断Bean是否配置了destroy-method，如果有，在销毁过程中会默认执行一次destroy-method方法。 Bean初始化过程在上一篇关于‘Spring初始化过程’的文章最后写到Spring初始化过程中最后执行的核心方法是AbstractRefreshableApplicationContext类的refresh方法。这里再次将其源码贴出. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 1.为应用上下文的刷新做准备--设置时间、记录刷新日志、初始化属性源中的占位符(事实上什么都没做)和验证必要的属性等 // Prepare this context for refreshing. prepareRefresh(); // 2.让子类刷新内部的bean factory // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); //3.为上下文准备bean factory // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // 4.bean factory 后置处理 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // 5.调用应用上下文中作为bean注册的工厂处理器 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // 6.注册拦截创建bean的bean处理器 // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 7.初始化消息源 // Initialize message source for this context. initMessageSource(); // 8.初始化事件广播 // Initialize event multicaster for this context. initApplicationEventMulticaster(); // 9.初始化特定上下文子类中的其它bean // Initialize other special beans in specific context subclasses. onRefresh(); // 10.注册监听器bean // Check for listener beans and register them. registerListeners(); // 11.实例化所有的单例bean // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // 12.发布相应的事件 // Last step: publish corresponding event. finishRefresh(); &#125;catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; //销毁错误的资源 // Destroy already created singletons to avoid dangling resources. destroyBeans(); //重置刷新标志 // Reset 'active' flag. cancelRefresh(ex); //主动抛出异常 // Propagate exception to caller. throw ex; &#125; finally &#123; //重置内存缓存 // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125; &#125; 通过源码可以看出该方法是构建整个IOC容器的完成过程。其中每一行代码都是创建容器的一个流程。其中主要包括以下几个步骤： 构建BeanFactory 添加事件处理 创建 Bean 实例对象并构建Bean关系 触发被监听的事件 构建BeanFactory构建BeanFactory的操作主要包括步骤1、2、3。其中第一步在我看来并未做啥重要的事情，我们只需将焦点定在二三步即可。 在第二步中，obtainFreshBeanFactory方法主要调用了AbstractRefreshableApplicationContext#refreshBeanFactory方法： 123456789101112131415161718protected final void refreshBeanFactory() throws BeansException &#123; if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex); &#125; &#125; 在上述代码中清晰可见的说明了BeanFactory的创建过程，首先判断当前容器是否存在BeanFactory，如果有则销毁后在进行创建。通过try/catch中代码可见，BeanFactory的是DefaultListableBeanFactory的实例对象。 通过Idea查看DefaultListableBeanFactory的类图如下： 从这个图中发现除了 BeanFactory 相关的类外，还发现了与 Bean 的 register 相关。这在 refreshBeanFactory 方法中有一行 loadBeanDefinitions(beanFactory) 将找到答案，这个方法将开始加载、解析 Bean 的定义，也就是把用户定义的数据结构转化为 Ioc 容器中的特定数据结构。 对于WEB应用而言，其调用的是XmlWebApplicationContext#loadBeanDefinitions方法。 在BeanFactory创建成功后，Spring将创建的对象交于第三步，即prepareBeanFactory方法为其添加一些 Spring 本身需要的一些工具类。 添加事件处理在第4、5、6步中，这三行代码对 Spring 的功能扩展性起了至关重要的作用 。其中第4、5步的代码主要是让你可以在Bean已经被创建，但未被初始化之前对已经构建的 BeanFactory 的配置做修改；第6步代码主要是让你可以对以后再创建 Bean 的实例对象时添加一些自定义的操作 。 第4步，即postProcessBeanFactory方法。主要功能为允许上下文能对BeanFactory做一些处理。比如：AbstractRefreshableWebApplicationContext抽象类实现了该方法，并在方法中对Servlet做了一些处理。 第5步，即invokeBeanFactoryPostProcessors方法主要是获取实现 BeanFactoryPostProcessor 接口的子类。其中主要包括执行BeanDefinitionRegistryPostProcessor类型的postProcessBeanDefinitionRegistry方法，以及执行非BeanDefinitionRegistryPostProcessor类型的postProcessBeanFactory方法。当然，该方法传入的参数是ConfigurableListableBeanFactory 类型，我们仅能对BeanFactory的一些配置做修改。 第6步，即registerBeanPostProcessors 方法也是可以获取用户定义的实现了 BeanPostProcessor 接口的子类，并执行把它们注册到 BeanFactory 对象中的 beanPostProcessors 变量中。BeanPostProcessor 中声明了两个方法：postProcessBeforeInitialization、postProcessAfterInitialization 分别用于在 Bean 对象初始化时执行。可以执行用户自定义的操作。 第7、8、9、10步的方法主要是初始化监听事件和对系统的其他监听者的注册，监听者必须是 ApplicationListener 的子类。 在容器启动时，Spring会调用ApplicationStartListener的onApplicationEvent方法。 创建 Bean 实例对象并构建Bean关系Bean的实例化过程是第11步开始的，即finishBeanFactoryInitialization方法，而在finishBeanFactoryInitialization方法中核心方法又为preInstantiateSingletons（DefaultListableBeanFactory类）。在该方法中，首先拿到所有beanName，然后在实例化的时候会判断bean是否为FactoryBean，顾名思义，这是一个特殊的工厂Bean，可以产生Bean的Bean。 这里的产生 Bean 是指 Bean 的实例，如果一个类继承 FactoryBean 用户只要实现他的 getObject 方法，就可以自己定义产生实例对象的方法。然而在 Spring 内部这个 Bean 的实例对象是 FactoryBean，通过调用这个对象的 getObject 方法就能获取用户自定义产生的对象，从而为 Spring 提供了很好的扩展性。Spring 获取 FactoryBean 本身的对象是在前面加上 &amp; 来完成的。 在Bean的实例化主要分两个步骤： Bean不为抽象、单例、非懒加载。 判断Bean是否为FactoryBean，是则执行FactoryBean相关的操作，否则直接调用getBean方法产生实例。 在singleton的bean初始化完了之后调用SmartInitializingSingleton的afterSingletonsInstantiated方法。 通过跟进Bean实例化代码可以发现getBean方法最后指向的是AbstractBeanFactory类的抽象方法createBean，其实现类为AbstractAutowireCapableBeanFactory。在该方法中有一个步骤会去查找Bean的依赖关系，并对其进行依赖注入操作。这里画一个时序图来作说明。 需要注意的是，在resolveValueIfNecessary方法中，不仅有调用resolveReference，同样的还有resolveInnerBean，即解析内部的Bean引用。 触发被监听的事件在经历第11步后，上下文的创建就已经基本完成了，这时Spring会执行finishRefresh方法，完成此上下文的刷新。其中包括LifecycleProcessor的onRefresh方法，并执行ContextRefreshedEvent事件。例如：执行SpringMVC的事件。 总结在Bean声明周期中曾讲到，Spring在初始化Bean的时候先后对调用BeanPostProcessor接口的postProcessBeforeInitialization、postProcessAfterInitialization方法。利用这一特性我们可以在Bean中实现BeanPostProcessor接口，然后再方法体中加入自己的逻辑。 对于Spring的IOC容器而言，除了BeanPostProcessor，还有BeanFactoryPostProcessor。顾明思议，BeanFactoryPostProcessor是在构建BeanFactory和构建Bean对象时调用。IOC容器允许BeanFactoryPostProcessor在容器初始化任何Bean之前对BeanFactory配置进行修改。 在Spring的IOC容器中还有一个特殊的Bean，即FactoryBean，FactoryBean主要用于初始化其他Bean，我们可以自己实现一个FactoryBean，然后添加自定义实例化逻辑。在Spring中，AOP、ORM、事务管理等都是依靠FactoryBean的扩展来实现的。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringApplicationContext初始化过程]]></title>
    <url>%2Fjava%2F2018%2Fspringapplicationcontext-chu-shi-hua-guo-cheng%2F</url>
    <content type="text"><![CDATA[SpringApplicationContext初始化过程ContextLoaderListener在SpringBoot面世之前。在一般的WEB项目中，项目的启动都是从web.xml开始的，如果我们想在项目中使用Spring，只需在web.xml文件中指定以下内容即可： 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 通过以上代码片段不难看出Spring正是通过ContextLoaderListener监听器来进行容器初始化的，查看ContextLoaderListener源码： 12345678910111213141516public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123; public ContextLoaderListener() &#123; &#125; public ContextLoaderListener(WebApplicationContext context) &#123; super(context); &#125; @Override public void contextInitialized(ServletContextEvent event) &#123; initWebApplicationContext(event.getServletContext()); &#125; @Override public void contextDestroyed(ServletContextEvent event) &#123; closeWebApplicationContext(event.getServletContext()); ContextCleanupListener.cleanupAttributes(event.getServletContext()); &#125;&#125; 根据该类中的注释可以看出initWebApplicationContext方法为核心的初始化方法，从initWebApplicationContext方法源代码可以看出Spring初始化容器主要分为以下几个步骤： 创建容器WebApplicationContext 验证当前容器是否为可配置的，是则配置并且刷新当前容器 将当前创建的容器设置到servlet上下文中 SpringBoot中的Spring 上文根据一般WEB项目跟踪了Spring容器初始化过程，但是从上诉过程并不能相对明显地看出Spring容器初始化过程。 在SpringBoot面世后，它简化了许多的配置方式，在SpringBoot中只需引入相应的start即可使用Spring，接下来就去看看SpringBoot中的Spring吧。 通过SpringBoot入口方法SpringApplication.run可以看到以下代码： 12345678910111213141516ApplicationArguments applicationArguments = new DefaultApplicationArguments( args);ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);configureIgnoreBeanInfo(environment);Banner printedBanner = printBanner(environment);//创建容器context = createApplicationContext();exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);//容器准备工作prepareContext(context, environment, listeners, applicationArguments, printedBanner);//刷新容器refreshContext(context); 其中，创建容器容器的方法是createApplicationContext，createApplicationContext方法会根据当前启动类型去初始化不同的Spring容器，主要类型为以下三种： NONE：非WEB，普通应用程序 REACTIVE：反应堆栈Web容器(5.x新加) SERVLET：Web容器 ps:反应堆栈Web容器，即WebFlux框架，该框架是Spring 5.x新加的框架，详细内容请访问SpringCloud中文网：https://springcloud.cc/web-reactive.html prepareContextprepareContext方法是做context的准备工作，该方法主要对容器进行一些预设置，源码中，该方法中的postProcessApplicationContext方法向beanFactory中添加了一个beanNameGenerator： 1234567891011121314151617protected void postProcessApplicationContext(ConfigurableApplicationContext context) &#123; if (this.beanNameGenerator != null) &#123; context.getBeanFactory().registerSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, this.beanNameGenerator); &#125; if (this.resourceLoader != null) &#123; if (context instanceof GenericApplicationContext) &#123; ((GenericApplicationContext) context) .setResourceLoader(this.resourceLoader); &#125; if (context instanceof DefaultResourceLoader) &#123; ((DefaultResourceLoader) context) .setClassLoader(this.resourceLoader.getClassLoader()); &#125; &#125; &#125; 其中，BeanNameGenerator用来生成扫描到的Bean在容器中的名字。 在prepareContext方法中，applyInitializers也是一个颇为重要的内容，通过查询资料发现该方法主要是对已创建的并且未被刷新的容器进行设置的自定义应用上下文初始化器。 refreshContext通过跟踪refreshContext方法不难发现，其最终执行的是AbstractRefreshableApplicationContext类中的refresh方法，其源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void refresh() throws BeansException, IllegalStateException &#123; Object var1 = this.startupShutdownMonitor; synchronized(this.startupShutdownMonitor) &#123; // 为应用上下文的刷新做准备--设置时间、记录刷新日志、初始化属性源中的占位符(事实上什么都没做)和验证必 要的属性等 this.prepareRefresh(); // 让子类刷新内部的bean factory ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); //为上下文准备bean factory this.prepareBeanFactory(beanFactory); try &#123; // bean factory 后置处理 this.postProcessBeanFactory(beanFactory); // 调用应用上下文中作为bean注册的工厂处理器 this.invokeBeanFactoryPostProcessors(beanFactory); // 注册拦截创建bean的bean处理器 this.registerBeanPostProcessors(beanFactory); // 初始化消息源 this.initMessageSource(); // 初始化事件广播 this.initApplicationEventMulticaster(); // 初始化特定上下文子类中的其它bean this.onRefresh(); // 注册监听器bean this.registerListeners(); // 实例化所有的单例bean this.finishBeanFactoryInitialization(beanFactory); // 发布相应的事件 this.finishRefresh(); &#125; catch (BeansException var9) &#123; if (this.logger.isWarnEnabled()) &#123; this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9); &#125; //销毁错误的资源 this.destroyBeans(); //重置刷新标志 this.cancelRefresh(var9); throw var9; &#125; finally &#123; this.resetCommonCaches(); &#125; &#125; &#125; 从以上代码的注释，可以看出refresh方法是Spring容器初始化的过程中加载Bean至关重要的一环，其职责主要是获取Bean，并初始化Bean。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计与设计原则]]></title>
    <url>%2Fjava%2F2018%2Fmian-xiang-dui-xiang-he-ji-she-ji-yuan-ze%2F</url>
    <content type="text"><![CDATA[面向对象设计与设计原则面向对象基本概念 面向对象程序设计(Object-oriented programming即OOP)是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。 面向对象编程的两个重要概念是类和对象。 类：类是变量与作用这些变量的方法集合，事物都具有其自身的属性和方法，通过这些属性和方法可以将不同的物质区分开来。 对象：对象是类进行实例化后的产物，是一个实体。 面向对象基本特征封装封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类进行信息隐藏。 继承继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”。 被继承的类称为“基类”、“父类”或“超类”。 继承的过程，就是从一般到特殊的过程。 继承概念的实现方式有三类：实现继承、接口继承和可视继承。 实现继承：使用基类的属性和方法而无需额外编码的能力； 接口继承：仅使用属性和方法的名称、但是子类必须提供实现的能力； 可视继承：子窗体（类）使用基窗体（类）的外观和实现代码的能力。 OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。 多态所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。 最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。 实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名(方法签名：方法名+形参列表)必须不同于原先方法的，但对于覆盖签名必须相同。 面向对象设计原则开闭原则 开闭原则(Open Close Principle即OCP)是Java中最基础的设计原则，它可以帮助我们建立一个稳定、灵活的系统。 定义软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。 实例分析我们假设当前有一个书籍销售的功能模块，程序原本的类图如下： 此时，因为书店打折活动，书籍价格会产生变化，我们需要修改程序的getPrice()方法，我们可以修改接口IBook，也可以修改其实现类NovelBook，但是这样的话都会在类中产生两个读取价格的方法，顾这两种方法都不是最优的解决办法。如下图所示，我们新建一个OffNovelBook，让其继承NovelBook并重写getPrice方法，新建高层类，通过复写来改变业务逻辑，减少底层代码的修改，减少代码风险。 我们可以把变化归类为两种类型： 逻辑变化：只变化了一个逻辑，而不涉及到其他模块的变化，可以直接修改原有类中的方法来实现，但这有一个前提条件是所有依赖或关联都按照相同的逻辑处理。 子模块变化：一个模块的变化，会对其他模块产生影响，特别是一个低层次的模块变化必然引起高层模块的变化，因此诸如此类的变化应通过扩展来完成。 总结 抽象约束 ：通过接口或抽象类约束扩展，对扩展进行边界限定 ；参数类型、引用对象尽量使用接口或抽象类，而不是具体的实现类 ；抽象层尽量保持稳定，一旦确定就不要修改 。 元数据（metadata）控制模块行为 ：元数据就是用来描述环境和数据的数据。尽量使用元数据来控制程序的行为，减少重复开发 。 封装变化：将相同的变化封装到一个接口或抽象类中，不同的变化应封装在不同的接口或抽象类中，否则即违背了单一职责原则。 单一职责原则 单一职责原则(Single Responsibility Principle即SRP)，其核心的思想是： 一个类，最好只做一件事，只有一个引起它变化的原因。 定义单一职责，强调的是职责的分离，在某种程度上对职责的理解，构成了不同类之间耦合关系的设计关键，因此单一职责原则或多或少成为设计过程中一个必须考虑的基础性原则。 实例分析1234567public void addProduct() &#123; if (!getCuurentUserPermission.contains("product.add")) &#123; //当前用户不具有add权限 return; &#125; //业务逻辑&#125; 从以上代码，我们不难看出，如果该功能对应的权限规则发生了变化 ，那么我们需要对系统中所有诸如此类的类进行修改。这将大大降低程序的稳定性，同时也会大大的提高我们得工作量。 对于这种情况我们可以新建一个类(权限控制类，比如shiro框架)来做处理。在shrio框架中，可以通过注解的方式去配置权限代码来实现权限控制，同理我们也可自己写一个方法，例如：PermisssionUtils.haveRight(String permissionCode)，在调用addProduct之前去判断是否拥有权限，从而使业务逻辑与权限控制两个职责分离。 12PermisssionUtils.haveRight("product.add");addProduct(); 总结单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责，通常意味着单一的功能，因此不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 里氏替换原则 里氏替换原则(Liskov Substitution Principle,即LSP)：所有引用父类的地方必须能使用其子类的对象。 定义所有引用父类的地方必须能使用其子类的对象： 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用父类对象。 实例分析在下文关于依赖倒置原则的实例中： 123456789public class Client &#123; public static void main(String[] args) &#123; People jim = new Jim(); Fruit apple = new Apple(); Fruit banana = new Banana(); jim.eat(apple); jim.eat(banana); &#125;&#125; 我们将Banana赋值给其父类Banana，并且在执行jim.eat(Banana)方法时得到了我们期望的结果。 总结里氏替换原则是实现开闭原则的重要方式之一，由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。通常我们会使用接口或者抽象方法定义基类，然后子类中实现父类的方法，并在运行时通过各种手段进行类型选择调用（比如反射）。 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 我们在运用里氏替换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏替换原则是开闭原则的具体实现手段之一。这也就是我们应该更多的依赖抽象，尽量少的依赖实现细节， 也就是依赖倒置原则。 依赖倒置原则 依赖倒置原则(Dependency Inversion Principle即DIP) 定义 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 抽象：抽象类或接口，两者是不能被实例化的 细节：抽象具体的实现类，实现接口或继承抽象类所产生的类（可以被实例化的类） 实例分析12345678910111213141516171819//具体Jim人类public class Jim &#123; public void eat(Apple apple)&#123; System.out.println("Jim eat " + apple.getName()); &#125;&#125;//具体苹果类public class Apple &#123; public String getName()&#123; return "apple"; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Jim jim = new Jim(); Apple apple = new Apple(); jim.eat(apple); &#125;&#125; 从上述代码，我们不难看出，该程序所表示的人吃苹果。此时我们如果要加一条人吃香蕉，只能先定义一个Banana类，然后在修改Jim类，在其中加一个吃香蕉的方法。加一种尚且如此，那么加n种呢？并且修改Jim类的操作会大大减少系统的稳健性，顾应根据依赖倒置原则对源码进行修改，修改如下： 1234567891011121314151617181920212223242526272829303132333435//人接口public interface People &#123; public void eat(Fruit fruit);//人都有吃的方法，不然都饿死了&#125;//水果接口public interface Fruit &#123; public String getName();//水果都是有名字的&#125;//具体Jim人类public class Jim implements People&#123; public void eat(Fruit fruit)&#123; System.out.println("Jim eat " + fruit.getName()); &#125;&#125;//具体苹果类public class Apple implements Fruit&#123; public String getName()&#123; return "apple"; &#125;&#125;//具体香蕉类public class Banana implements Fruit&#123; public String getName()&#123; return "banana"; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; People jim = new Jim(); Fruit apple = new Apple(); Fruit banana = new Banana(); jim.eat(apple); jim.eat(banana); &#125;&#125; 总结总而言之，依赖倒置原则的核心就是面向接口编程，对于一些底层类都提取抽象类和公共接口，顶层类依赖抽象类或接口而不直接依赖具体实现。 依赖倒置原则的本质是通过抽象类或接口使各个类或模块的实现彼此独立，不相互影响，实现模块之间的松耦合。 在多人协作时，我们还可以遵循依赖倒置原则去设计程序，提取抽象，使得各模块相对独立，提升并行开发效率，提高开发速度。 接口隔离原则 接口隔离原则(Interface Segregation Principle, 即ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 定义 客户端不应该依赖它不需要的接口。 类间的依赖关系应该建立在最小的接口上。 接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只知道他们感兴趣的方法。 实例分析例如：客户端的用户需要登录、登出、修改密码等操作，而后台的管理员则可以修改用户资料、删除用户等操作。 123456789public interface UserService&#123; public void login(); public void logout(); public void changePassword();&#125;public interface AdminUserService extends UserService &#123; public void updateUser(User user); public void deleteUser(User user);&#125; 总结接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。 接口隔离原则与前面的单一职责原则相辅相成。但单一职责原则并不保证客户程序只知道必要的信息，甚至在有些情况下接口隔离原则与单一职责原则会出现一定的冲突，设计时我们要根据用户界面,性能等因素决策.。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 迪米特法则 迪米特法则(Law of Demeter, 即LOD)：一个软件实体应当尽可能少地与其他实体发生相互作用。 迪米特法则又称为最少知识原则(LeastKnowledge Principle,即LKP) 定义不要和“陌生人”说话、只与你的直接朋友通信 在迪米特法则中，对于一个对象，其朋友包括以下几类： 当前对象本身(this) 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响 。 实例分析例如：现在用户像好友发送消息，用户可以对单个好友发送消息，也可以发送群消息。 从上图不难看出，我们专门引入了一个MessageService用与控制消息转发，同时降低UserService与各系统之间的耦合度。当需要新增功能时，只需修改MessageSerice即可。 总结迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 在运用迪米特恩法则时应注意以下几点： 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。 在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 组合/聚合复用原则 组合/聚合复用原则（Composite/Aggregate Reuse Principle 即CARP） 定义组合和聚合都是对象建模中关联（Association）关系的一种.聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。在合成关系中，部分和整体的生命周期一样，组合的新的对象完全支配其组成部分，包括他们的创建和销毁。一个合成关系中成分对象是不能与另外一个合成关系共享。 实例分析组合/聚合和继承是实现复用的两个基本途径。合成复用原则是指尽量使用合成/聚合，而不是使用继承。 只有当以下的条件全部被满足时，才应当使用继承关系。 继承复用破坏包装，它把父类的实现细节直接暴露给了子类，这违背了信息隐藏的原则。 如果父类发生了改变，那么子类也要发生相应的改变，这就直接导致了类与类之间的高耦合，不利于类的扩展、复用、维护等，也带来了系统僵硬和脆弱的设计。 合成和聚合的时候新对象和已有对象的交互往往是通过接口或者抽象类进行的，就可以很好的避免上面的不足，而且这也可以让每一个新的类专注于实现自己的任务，符合单一职责原则。 判断方法： 1.使用“Has-A”和“Is-A”来判断： “Has-A”：代表的是 对象和它的成员的从属关系。同一种类的对象，通过它们的属性的不同值来区别。比如一个人可以是医生、警察、教师等。此时可使用继承关系。 “Is-A”：代表的是类之间的继承关系，比如一个人可以是男人、女人。此时应使用组合/聚合。 2.使用里氏替换原则来判断 里氏代换原则是继承复用的基础。 总结继承的缺点： 继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。 基类的实现发生了改变，派生类的实现也不得不改变。 从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。 组合/聚合优点： 新对象存取组成对象的唯一方法是通过组成对象的getter/setter方法。 组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。 组合复用所需要的依赖较少。 每一个新的类可以将焦点集中到一个任务上。 组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。 组合/聚合缺点：组合复用建造的系统会有较多的对象需要管理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-总览]]></title>
    <url>%2Fjava%2F2018%2Fshe-ji-mo-shi-zong-lan%2F</url>
    <content type="text"><![CDATA[设计模式-总览 设计模式（Design pattern）是一种被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。即：在某些场景下，针对某类问题的某种通用的解决办法 设计模式分类 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程 结构型模式： 把类或对象结合在一起形成一个更大的结构 行为型模式 ：类和对象如何交互，及划分责任和算法 创建型设计模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则 。 创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 名称 重要程度 说明 链接 工厂模式(Factory) ★★★★★ 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 。 工厂模式 抽象工厂模式(Abstract Factory) ★★ 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类 工厂模式 建造者模式(Builder) ★★★ 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 建造者模式 原型模式(Prototype) ★★★ 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 原型模式 单例模式(Singleton) ★★★★ 在整个应用中保证只有一个类的实例存在。 单例模式 结构型设计模式 名称 重要程度 说明 链接 适配器模式( Adapter ) ★★★★ 定义一个包装类，用于包装不兼容接口的对象 桥接模式( Bridge ) ★★★ 将抽象部分与它的实现部分分离，使它们都可以独立地变化 组合模式( Composite ) ★★★★ 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性 装饰模式( Decorator ) ★★★ 动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活 外观模式( Facade ) ★★★★★ 外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 外观模式 亨元模式( Flyweight ) ★ 运用共享技术有效地支持大量细粒度对象的复用 代理模式( Proxy ) ★★★★ 给某一个对象提供一个代 理，并由代理对象控制对原对象的引用 行为型设计模式 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化 。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式主要分为以下两种： 类行为型模式 ：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式 名称 重要程度 说明 链接 责任链模式( Chain of Responsibility ) ★★★ 为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦 命令模式( Command ) ★★★★ 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作 解释器模式( Interpreter ) ★ 迭代器模式( Iterator ) ★★★★★ 提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节 中介者模式( Mediator ) ★★ 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 备忘录模式( Memento ) ★★ 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 观察者模式( Observer ) ★★★★★ 定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新 观察者模式 状态模式( State ) ★★★ 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类 策略模式( Strategy ) ★★★★ 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换 模板方法模式( Template Method) ) ★★★ 使得子类可以在不改变算法结构的情况下，重新定义算法中的某一些步骤 访问者模式( Visitor ) ★ 提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作 参考资料 http://design-patterns.readthedocs.io/zh_CN/latest/]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
